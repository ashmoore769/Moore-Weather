<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="apple-touch-icon" href="/Weather_Station_App.png">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <!-- Added Rubik font specifically for big temp boxes if desired -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"> <!-- Added viewport-fit=cover for safe area -->
  <title>Moore's LIVE Weather Data</title>
  <style>
    /* Base Styles */
    body {
      margin: 0;
      background-color: #f4f4f4;
      font-family: "Inter", "system-ui", "Segoe UI", "Helvetica Neue", Arial, sans-serif;
      font-size: 13.5px;
      font-weight: 400;
      line-height: 1.35;
      letter-spacing: 0.15px; /* ‚ú® NEW */
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: optimizeLegibility;
      /* Add padding for safe area (e.g., iPhone notches) */
      padding-top: env(safe-area-inset-top, 0);
      padding-left: env(safe-area-inset-left, 0);
      padding-right: env(safe-area-inset-right, 0);
      padding-bottom: env(safe-area-inset-bottom, 0);
    }

    .main-container {
      max-width: 400px;
      margin: 10px auto;
      padding: 0 5px;
    }

    /* Pulse animation for updated temp box */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); } /* Slightly larger pulse */
      100% { transform: scale(1); }
    }

    .big-temp-box.updated {
      animation: pulse 0.3s ease-in-out;
    }

    .freeze-pane {
      position: sticky;
      /* Ensure sticky respects safe area */
      top: env(safe-area-inset-top, 0);
      z-index: 100;
      background: #f4f4f4; /* Match body background */
      padding: 0; /* remove padding */
      /* Add a subtle shadow to indicate elevation */
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      margin-bottom: 5px; /* Add some space below the sticky pane */
    }

    .header-box {
      background-color: #00008B; /* Dark Blue */
      border-radius: 10px;
      padding: 5px;
      text-align: center;
    }

    .header-box h2 {
      margin: 0;
      font-size: 18px;
      font-weight: bold;
      color: white;
      padding: 4px 0;
      white-space: nowrap;
    }

    .control-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 2px;        /* reduce horizontal padding */
      margin-bottom: 0;      /* remove bottom margin */
      margin-top: 4px;       /* Add a little space above controls */
    }

    .control-half {
      width: 50%;
      text-align: center;
      white-space: nowrap;
    }

    button {
      padding: 6px 12px;
      font-size: 14px;
      font-weight: 600;
      font-family: "Inter", "system-ui", "Segoe UI", "Helvetica Neue", Arial, sans-serif;
      background-color: #FFA500; /* Orange */
      color: black;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: background 0.3s ease, transform 0.1s ease, box-shadow 0.2s ease; /* Added box-shadow transition */
      display: inline-block;
      margin: 2px 0;
      white-space: nowrap;
      line-height: 1.2;             /* Tighter for button text */
      letter-spacing: 0.3px;        /* Slight punch */
      box-shadow: 0 1px 2px rgba(0,0,0,0.15); /* Soft elevation */
      -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
    }

    button:hover {
      background-color: #e59400; /* Darker Orange */
      transform: scale(1.02);       /* Tiny lift on hover */
      box-shadow: 0 2px 4px rgba(0,0,0,0.2); /* Slightly larger shadow on hover */
    }

    button:active {
        transform: scale(0.98); /* Press effect */
        box-shadow: inset 0 1px 2px rgba(0,0,0,0.2); /* Inset shadow on press */
    }

    button:disabled {
      background-color: #cccccc; /* Lighter Gray */
      color: #666666;
      cursor: not-allowed;
      opacity: 0.7;
      box-shadow: none; /* No shadow when disabled */
      transform: none; /* No transform when disabled */
    }

    #status {
      /* Removed font-weight/size here, controlled by badge */
      white-space: nowrap;
      padding: 0;
      text-align: center; /* Center align the status text/badge */
    }

    /* Default badge style for all statuses */
    .status-badge {
      display: inline-block;
      padding: 6px 12px;
      font-size: 14px;
      font-weight: bold;
      border-radius: 10px;
      background-color: white;
      color: #808080; /* Default Gray */
      border: 2px solid #808080; /* Default Gray */
      line-height: 1;
      transition: all 0.3s ease;
      vertical-align: middle; /* Align with button better */
    }

    /* Connected state */
    .status-badge.connected {
      background-color: #006400; /* Dark Green */
      color: white;
      border-color: #006400; /* Dark Green */
    }

    /* Fetching state */
    .status-badge.fetching {
      color: #DAA520; /* Goldenrod */
      border-color: #DAA520; /* Goldenrod */
      background-color: white; /* Keep background white */
    }

    /* Error state */
    .status-badge.error {
      color: #B22222; /* Firebrick Red */
      border-color: #B22222; /* Firebrick Red */
      background-color: white; /* Keep background white */
    }

    .spinner-container {
      display: none; /* Hidden by default */
      margin: 20px auto;
      width: 30px; /* Smaller spinner */
      height: 30px;
    }

    .spinner {
      width: 100%;
      height: 100%;
      border: 3px solid #f3f3f3; /* Lighter border */
      border-top: 3px solid #007bff; /* Blue */
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Weather Data Container */
    #weatherData {
      background: #ffffff;
      padding: 8px 10px 12px 10px; /* slightly tighter padding */
      border-radius: 12px;         /* a bit more modern, softer */
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08); /* softer shadow */
      font-size: 13.5px;           /* matches body font size for consistency */
      color: #222;                 /* slightly darker for better contrast */
      text-align: left;
      margin-bottom: 15px;         /* reduce space before footer or next block */
      /* Add overflow handling just in case */
      overflow-x: hidden;
    }

    #weatherData p {
      margin: 3px 0; /* Slightly more vertical space between lines */
      line-height: 1.3;
      white-space: nowrap;
    }

    hr {
      border: none;
      border-top: 1px solid #e0e0e0; /* Lighter separator */
      margin: 6px 0; /* Slightly more space around separators */
      clear: both;
      width: 100%;
    }

    /* --- Header Layout --- */
    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center; /* center vertically */
      margin: 5px 0;
      white-space: nowrap;
      gap: 10px; /* Add gap between title/date and logos */
    }

    .title-date-container {
      display: flex;
      flex-direction: column;
      white-space: nowrap;
      flex-shrink: 0; /* Prevent shrinking */
    }

    .address-title {
      font-size: 18px; /* slightly reduced from previous 20px */
      font-weight: bold;
      margin: 0 0 2px 0;
      color: #00008B; /* Dark Blue */
      white-space: nowrap;
    }

    .date-time {
      margin: 0;
      white-space: nowrap;
    }

    .date-time p {
      margin: 1px 0; /* Tighter spacing within date/time block */
      line-height: 1.3;
      white-space: nowrap;
    }

    .logo-container {
      display: flex;
      gap: 5px;
      margin: 0;
      padding: 0;
      align-items: center; /* Vertically align logos */
      flex-shrink: 0; /* Prevent logos from shrinking */
    }

    .logo-container img {
      height: 60px; /* increased image size */
      width: auto;
      margin: 0;
      display: block;
      border-radius: 8px;
      object-fit: contain; /* Ensure images scale nicely */
    }

    /* --- Main Data Layout --- */
    .wind-logger-container {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      margin: 5px 0;
      white-space: nowrap;
    }

    .wind-column {
      width: calc(60% - 5px); /* Adjust width considering gap */
      white-space: nowrap;
    }

    .logger-column {
      width: calc(40% - 5px); /* Adjust width considering gap */
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start; /* Align boxes to top */
      white-space: nowrap;
    }

    .big-temp-box {
      width: 100px; /* Slightly wider */
      height: 40px; /* Slightly taller */
      padding: 4px 6px;
      border-radius: 10px;

      /* ‚ú® Depth and lighting */
      background: linear-gradient(to bottom, rgba(255,255,255,0.1), rgba(0,0,0,0.15));

      box-shadow:
        inset 0 0 4px rgba(0, 0, 0, 0.25),  /* inner glow */
        0 2px 6px rgba(0, 0, 0, 0.2);       /* outer drop shadow */

      font-size: 16px;
      font-family: 'Rubik', sans-serif; /* Use Rubik font */
      font-weight: bold;
      text-align: center;
      color: #FFF; /* White text */
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      word-wrap: break-word; /* Allow wrapping if needed */
      line-height: 1;
      letter-spacing: 0.2px;
      border: 1px solid rgba(255,255,255,0.4); /* Subtle border */
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      transition: background-color 0.3s ease; /* Smooth background color change */
    }

    .big-temp-box span.label {
      font-size: 11px; /* Slightly smaller label */
      font-weight: 600;
      color: white; /* Ensure label is white */
      margin-top: 2px;       /* Adjusted gap */
      line-height: 1.1;
      letter-spacing: 0.2px;
    }

    /* Space between stacked temp boxes */
    .big-temp-box + .big-temp-box {
      margin-top: 8px;
    }

    .rain-container {
      margin-top: 7px;
      margin-bottom: 3px;
      padding: 4px 6px; /* Added some padding */
      border: 1px solid #e0e0e0; /* Lighter border */
      border-radius: 8px;
      background: #f9f9f9;
      white-space: nowrap;
    }
     .rain-container p {
         margin: 2px 0; /* Tighter spacing inside rain box */
     }

    .evap-battery {
      display: flex;
      justify-content: space-between;
      gap: 10px; /* Add gap */
      margin: 5px 0;
      white-space: nowrap;
    }

    .evap-col {
      width: calc(52% - 5px); /* Adjust width */
      white-space: nowrap;
    }

    .battery-col {
      width: calc(48% - 5px); /* Adjust width */
      white-space: nowrap;
    }

    .soil-moisture {
      display: flex;
      justify-content: space-between;
      gap: 10px; /* Add gap */
      margin: 5px 0;
      white-space: nowrap;
    }

    .soiltemp-col, .moisture-col {
      width: calc(50% - 5px); /* Adjust width */
      white-space: nowrap;
    }

    /* Highlight specific data points */
    .highlight-bold {
      font-weight: bold;
    }
    .highlight-red {
      color: #B22222; /* Firebrick Red */
      font-weight: bold;
    }
    .highlight-orange {
       color: #FF8C00; /* Dark Orange */
       font-weight: bold;
    }
     .highlight-blue {
       color: #1E90FF; /* Dodger Blue */
       font-weight: bold;
    }
     .highlight-green {
       color: #006400; /* Dark Green */
       font-weight: bold;
    }
     .highlight-darkblue {
        color: #00008B; /* Dark Blue */
        font-weight: bold;
     }
     .highlight-lowsolar {
         color: #27408B; /* Dark Slate Blue */
     }
     .highlight-warmsolar {
         color: #DAA520; /* Goldenrod */
         font-weight: bold;
     }
     .highlight-hotsolar {
         color: #BF360C; /* Deep Orange */
         font-weight: bold;
     }
     .highlight-vryhotsolar {
         color: #B71C1C; /* Dark Red */
         font-weight: bold;
     }


    /* Media Queries for Mobile Devices */
    @media only screen and (max-width: 360px) { /* Adjust breakpoint if needed */
        body {
            font-size: 13px; /* Slightly smaller font on very small screens */
        }
         .header-box h2 {
            font-size: 16px;
        }
         button {
            font-size: 13px;
            padding: 5px 10px;
        }
        .status-badge {
            font-size: 13px;
            padding: 5px 10px;
        }
        .address-title {
            font-size: 16px;
        }
         .logo-container img {
             height: 50px;
         }
         #weatherData p {
             margin: 2px 0; /* Tighten spacing */
         }
         .big-temp-box {
            width: 90px;
            height: 36px;
            font-size: 14px;
        }
        .big-temp-box span.label {
            font-size: 10px;
        }
    }

    @media only screen and (max-width: 600px) {
      .main-container {
        max-width: 100%; /* Use full width */
        margin: 5px auto; /* was 10px auto */
        padding: 0 5px; /* Keep side padding */
      }

      .header-box {
        padding: 5px; /* Restore padding */
      }
    }
  </style>
</head>
<body>
  <div class="main-container">
    <!-- Sticky Header -->
    <div class="freeze-pane">
      <div class="header-box">
        <h2>Moore's LIVE Weather Data</h2>
      </div>
      <div class="control-container">
        <div class="control-half">
          <button id="fetchBtn" onclick="manualFetch()">CURRENT READINGS</button>
        </div>
        <div class="control-half">
          <p id="status" aria-live="polite">
            <span id="statusBadge" class="status-badge">Status: Waiting...</span>
          </p>
        </div>
      </div>
    </div>

    <!-- Spinner - moved above weather data for better visibility when loading initially -->
    <div id="spinnerContainer" class="spinner-container">
      <div class="spinner"></div>
    </div>

    <!-- Weather Data Section -->
    <div id="weatherData" style="display: none;"> <!-- Hidden initially, shown after first successful fetch -->
      <!-- Header Section -->
      <div class="header-content">
        <div class="title-date-container">
          <div class="address-title">WEST WARWICK, QLD</div>
          <div class="date-time">
            <p><b>üìÜ Date:</b> <span id="dateVal">--</span></p>
            <p><b>‚è∞ Time:</b> <span id="timeVal">--</span></p>
          </div>
        </div>
        <div class="logo-container">
          <img src="/Weather_Station_App.png" alt="Weather Station Icon">
          <img src="/Station_Label.png" alt="Environdata Weather Maestro">
        </div>
      </div>
      <hr>

      <!-- Main Data Columns -->
      <div class="wind-logger-container">
        <div class="wind-column">
          <p><b>üí® Wind Speed:</b> <span id="windSpeedVal">--</span> km/h</p>
          <p><b>üß≠ Wind Direction:</b> <span id="windDirDegVal">--</span>¬∞ (<span id="windDirTextVal">--</span>)</p>
          <p><b>üí¶ Humidity:</b> <span id="humidityVal">--</span>% (<span id="humidityDescVal">--</span>)</p>
          <p>
            <b>üå°Ô∏è Temperature:</b>
            <span id="tempVal" class="highlight-bold">--</span>
            (<span id="tempDescVal">--</span>)
          </p>
          <p><b>‚òÄÔ∏è Solar Radiation:</b> <span id="solarRadVal">--</span></p>
          <p><b>üîò Black Globe Temp:</b> <span id="blackGlobeTempVal">--</span>¬∞C</p>
          <p><b>üå± Garden Bed Temp:</b> <span id="gardenBedTempVal">--</span>¬∞C</p>
          <p><b>üåÄ Pressure:</b> <span id="pressureVal">--</span></p>
          <div class="rain-container">
            <p><b>üåßÔ∏è Rain Since 9AM:</b> <span id="rainSince9Val">--</span></p>
            <p><b>üåßÔ∏è Rain In Last Min:</b> <span id="rainInLastMinVal">--</span></p>
          </div>
        </div>
        <div class="logger-column">
          <div class="big-temp-box" id="airTempBox">
            <span id="bigTempVal">--¬∞C</span>
            <span class="label">Air Temp</span>
          </div>
          <div class="big-temp-box" id="radiantDiffBox">
            <span id="radiantDiffVal">--¬∞C</span>
            <span class="label" aria-label="Difference between Black Globe and Air temperature">Radiant Heat Diff</span>
          </div>
          <div class="big-temp-box" id="dewDiffBox">
            <span id="dewDiffVal">--¬∞C</span>
            <span class="label" aria-label="Temperature difference above Dew Point">Temp Above Dew Pt.</span>
          </div>
        </div>
      </div>
      <hr>
      <!-- Evaporation and Battery Section -->
      <div class="evap-battery">
        <div class="evap-col">
          <p><b>‚§¥Ô∏è Evap/Hr:</b> <span id="evapRateVal">--</span> mm/h</p>
          <p><b>‚¨ÜÔ∏è Daily Evap:</b> <span id="dailyEvapVal">--</span> mm</p>
          <p><b>üíß Dew Point:</b> <span id="dewPointVal">--</span>¬∞C</p>
          <p><b>üå¨Ô∏è Max WS Gust:</b> <span id="peakWindGustVal">--</span></p> <!-- Clarified Gust Period -->
        </div>
        <div class="battery-col">
          <p><b>üîã Battery:</b> <span id="batteryVal">--</span></p>
          <p><b>‚ö° Load:</b> <span id="loadVal">--</span> mA</p>
          <p><b>‚òÄÔ∏è Solar Panel:</b> <span id="solarPanelVal">--</span></p>
          <p><b>üîå Charge:</b> <span id="chargeVal">--</span></p>
        </div>
      </div>
      <hr>
      <!-- Additional Data -->
      <p><b>üçÉ Vector Wind Speed:</b> <span id="vectorWindSpeedVal">--</span> km/h</p>
      <p>
        <b>üß≠ Vector Wind Direction:</b>
        <span id="vectorWindDirDegVal">--</span>¬∞ (<span id="vectorWindDirTextVal">--</span>)
      </p>
      <hr>
      <div class="soil-moisture">
        <div class="soiltemp-col">
          <p><b>üå°Ô∏è S. Temp 10cm:</b> <span id="soilTemp10Val">--</span>¬∞C</p>
          <p><b>üå°Ô∏è S. Temp 20cm:</b> <span id="soilTemp20Val">--</span>¬∞C</p>
          <p><b>üå°Ô∏è S. Temp 30cm:</b> <span id="soilTemp30Val">--</span>¬∞C</p>
          <p><b>üå°Ô∏è S. Temp 40cm:</b> <span id="soilTemp40Val">--</span>¬∞C</p>
        </div>
        <div class="moisture-col">
          <p><b>üíß Moist. 10cm:</b> <span id="moisture10Val">--</span>%</p>
          <p><b>üíß Moist. 20cm:</b> <span id="moisture20Val">--</span>%</p>
          <p><b>üíß Moist. 30cm:</b> <span id="moisture30Val">--</span>%</p>
          <p><b>üíß Moist. 40cm:</b> <span id="moisture40Val">--</span>%</p>
        </div>
      </div>
      <hr>
      <!-- Footer/Timestamp -->
      <p style="text-align: center; font-size: 11px; color: #666; margin-top: 10px;">
        Last updated: <span id="lastUpdatedTimestamp">--</span>
      </p>
    </div>

  </div>

  <script>
    /********************
    * HELPER FUNCTIONS *
    ********************/
    function getWindDirection(degrees) {
      // Ensure degrees is within 0-360 range
      const normalizedDegrees = ((degrees % 360) + 360) % 360;
      const directions = ["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE",
        "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"];
      return directions[Math.round(normalizedDegrees / 22.5) % 16];
    }

    function setStatusBadge(statusText, statusClass) {
      const icons = {
        connected: "‚úÖ",
        fetching: "üîÑ",
        error: "‚ö†Ô∏è",
        waiting: "‚è≥" // Added waiting state
      };
      const icon = icons[statusClass] || "";
      const badge = document.getElementById("statusBadge");
      badge.textContent = `${icon} Status: ${statusText}`;
      badge.className = `status-badge ${statusClass}`; // Apply status class
    }

    function formatDateString(dateStr) {
        // Input format: YYYY/MM/DD
      const parts = dateStr.split("/");
      if (parts.length === 3) {
        const [year, month, day] = parts;
        // Check if parts are valid numbers before creating Date object
        if (!isNaN(year) && !isNaN(month) && !isNaN(day)) {
            const formattedDate = `${day.padStart(2, '0')}/${month.padStart(2, '0')}/${year}`;
            // Note: Month is 0-indexed in Date constructor
            const dateObj = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
            // Check if Date object is valid
            if (!isNaN(dateObj.getTime())) {
                const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
                return `${formattedDate} (${dayNames[dateObj.getDay()]})`;
            }
        }
      }
      console.warn("Could not parse date string:", dateStr);
      return dateStr; // Return original string if parsing fails
    }

    function getTemperatureColorAndDesc(temp) {
      let color, desc;
      // Define thresholds and corresponding styles
      const thresholds = [
          { limit: -20, color: "#000000", desc: "" }, // Use hex for consistency
          { limit: -10, color: "#191970", desc: "Severely cold" }, // Midnight Blue
          { limit: 0,   color: "#00008B", desc: "Extremely cold" }, // Dark Blue
          { limit: 6,   color: "#104E8B", desc: "Very cold" }, // Dark Slate Blue
          { limit: 11,  color: "#4682B4", desc: "Cold" }, // Steel Blue
          { limit: 16,  color: "#32CD32", desc: "Cool" }, // Lime Green
          { limit: 21,  color: "#228B22", desc: "Mild" }, // Forest Green
          { limit: 28,  color: "#DAA520", desc: "Warm" }, // Goldenrod
          { limit: 32,  color: "#FF8C00", desc: "Warmer" }, // Dark Orange
          { limit: 36,  color: "#FF4500", desc: "Hot" }, // Orange Red
          { limit: 41,  color: "#B22222", desc: "Very hot" }, // Firebrick
          { limit: 61,  color: "#8B0000", desc: "Extremely hot" }, // Dark Red
          { limit: Infinity, color: "#000000", desc: "" }
      ];

      // Find the correct style based on temperature
      for (let i = 0; i < thresholds.length; i++) {
          if (temp < thresholds[i].limit) {
              color = thresholds[i].color;
              desc = thresholds[i].desc;
              break;
          }
      }
       // Return default black if somehow missed (shouldn't happen with Infinity)
      return { color: color || "#000000", desc: desc || "" };
    }

    function getHumidityDesc(humidity) {
      if (humidity <= 20) { return "Very Dry"; }
      else if (humidity <= 40) { return "Dry"; }
      else if (humidity <= 60) { return "Comfortable"; }
      else if (humidity <= 80) { return "Humid"; }
      else { return "Very Humid"; }
    }

    function colorMoisture(val) {
        // Ensure val is a number
        const numVal = parseFloat(val);
        if (isNaN(numVal)) return '--'; // Handle non-numeric input

        let display = numVal.toFixed(1);
        // Use CSS classes for styling moisture levels
        if (numVal < 20) {
            display = `<span class="highlight-orange">${display}</span>`; // Dry
        } else if (numVal > 60) { // Example: Add a style for very wet
            display = `<span class="highlight-blue">${display}</span>`; // Wet
        }
        return display;
    }

    // Helper to update element text, returns true if changed
    function updateText(id, value) {
        const element = document.getElementById(id);
        if (element) {
            if (element.textContent !== value) {
                element.textContent = value;
                return true;
            }
            return false;
        }
        console.warn(`Element with ID ${id} not found.`);
        return false;
    }

    // Helper to update element HTML, returns true if changed
    function updateHTML(id, value) {
        const element = document.getElementById(id);
        if (element) {
             if (element.innerHTML !== value) {
                element.innerHTML = value;
                return true;
             }
             return false;
        }
        console.warn(`Element with ID ${id} not found.`);
        return false;
    }


    /*****************************
    * GLOBAL STATE & CONSTANTS *
    *****************************/
    let initialLoadComplete = false;
    let refreshTimeout;
    let retryAttempts = 0;
    const MAX_RETRY_ATTEMPTS = 3;
    const WEATHER_ENDPOINT = "/weather"; // Use a relative path
    const RETRY_DELAY_SHORT = 500; // ms
    const RETRY_DELAY_LONG = 1000; // ms
    const MAX_BACKOFF_DELAY = 30000; // 30 seconds max between retries after initial failures
    const SCHEDULE_TARGET_SECOND = 20; // Target second past the minute for refresh

    /*****************************
    * MAIN UPDATE FUNCTION *
    *****************************/
    function updateWeatherData(data) {
      console.log("Raw data received:", data);
      // Assumption: Data is comma-separated, potentially with a leading identifier like "r3" followed by CRLF
      const cleanedData = data.replace(/^r\d+\r?\n?/, "").trim(); // Remove potential prefix like r3, r4 etc.
      const lines = cleanedData.split(",");
      console.log("Parsed lines array:", lines);

      // Minimum expected fields. Adjust if format changes. Currently needs up to index 30.
      const MIN_EXPECTED_FIELDS = 31;
      if (lines.length < MIN_EXPECTED_FIELDS) {
        console.error(`Incomplete data received. Expected at least ${MIN_EXPECTED_FIELDS} fields, got ${lines.length}:`, lines);
        // Don't clear data if already loaded, show error in status
        setStatusBadge("Data Error", "error");
        // Optionally: Display a message in the data area if it's the initial load
        if (!initialLoadComplete) {
             document.getElementById("weatherData").innerHTML = `<p style="color: red; text-align: center; padding: 20px;"><b>Error:</b> Incomplete or malformed data received from station.</p>`;
             document.getElementById("weatherData").style.display = "block"; // Show the error message area
        }
        return false; // Indicate update failure
      }

      try {
        // Extract data using indices - CONSIDER using constants or an object mapping for robustness
        const dateStr = lines[0];
        const timeStr = lines[1];
        const windSpeed = parseFloat(lines[2]);
        const windDirDeg = parseFloat(lines[3]);
        const humidityRaw = parseFloat(lines[4]);
        const temperatureRaw = parseFloat(lines[5]);
        let rainInLastMinRaw = parseFloat(lines[6]);
        const solarRadRaw = parseFloat(lines[7]);
        const pressureRaw = parseFloat(lines[8]);
        const gardenBedTemp = parseFloat(lines[9]);
        const batteryVoltageVal = parseFloat(lines[10]);
        const loadCurrent = parseFloat(lines[11]);
        const rawSolarVoltage = parseFloat(lines[12]);
        const chargeCurrent = parseFloat(lines[13]);
        const peakWindGustVal = parseFloat(lines[14]); // Assumed 10-min peak gust
        const vectorWindSpeedVal = parseFloat(lines[15]);
        const vectorWindDirVal = parseFloat(lines[16]);
        const rainSince9 = parseFloat(lines[17]);
        const evapRate = parseFloat(lines[18]);
        // Index 19 is often unused or reserved (e.g., pan evap)
        const dailyEvap = parseFloat(lines[20]);
        const dewPoint = parseFloat(lines[21]);
        const soilTemp10 = parseFloat(lines[22]);
        const soilTemp20 = parseFloat(lines[23]);
        const soilTemp30 = parseFloat(lines[24]);
        const soilTemp40 = parseFloat(lines[25]);
        const moisture10Val = parseFloat(lines[26]);
        const moisture20Val = parseFloat(lines[27]);
        const moisture30Val = parseFloat(lines[28]);
        const moisture40Val = parseFloat(lines[29]);
        const blackGlobeTemp = parseFloat(lines[30]);

        // --- Basic Data Validation ---
        // Check a few key numeric values. Add more checks if needed.
        if (isNaN(windSpeed) || isNaN(humidityRaw) || isNaN(temperatureRaw) || isNaN(pressureRaw) || isNaN(blackGlobeTemp)) {
          console.error("Invalid numeric data received in key fields:", lines);
          setStatusBadge("Data Error", "error");
          if (!initialLoadComplete) {
             document.getElementById("weatherData").innerHTML = `<p style="color: red; text-align: center; padding: 20px;"><b>Error:</b> Invalid data values received from station.</p>`;
             document.getElementById("weatherData").style.display = "block";
          }
          return false; // Indicate update failure
        }

        // If validation passes, make the data area visible
        document.getElementById("weatherData").style.display = "block";

        // --- Update DOM Elements ---

        // DATE & TIME
        updateText("dateVal", formatDateString(dateStr));
        updateText("timeVal", timeStr + " AEST");

        // WIND
        updateText("windSpeedVal", windSpeed.toFixed(1));
        updateText("windDirDegVal", windDirDeg.toFixed(1));
        updateText("windDirTextVal", getWindDirection(windDirDeg));

        // HUMIDITY
        updateText("humidityVal", humidityRaw.toFixed(1));
        updateText("humidityDescVal", getHumidityDesc(humidityRaw));

        // TEMPERATURE
        const tempData = getTemperatureColorAndDesc(temperatureRaw);
        const tempFormatted = temperatureRaw.toFixed(1) + "¬∞C";
        const tempSpan = document.getElementById("tempVal");
        if (tempSpan) {
            tempSpan.textContent = tempFormatted;
            tempSpan.style.color = tempData.color;
        }
        updateText("tempDescVal", tempData.desc);

        // Big Temperature Box (Air Temp)
        const bigTempElement = document.getElementById("bigTempVal");
        const bigTempContainer = document.getElementById("airTempBox");
        if (bigTempElement && bigTempContainer) {
            if (bigTempElement.textContent !== tempFormatted) {
                 bigTempElement.textContent = tempFormatted;
                 bigTempContainer.style.backgroundColor = tempData.color;
                 // Trigger pulse animation only if the value changed
                 bigTempContainer.classList.add('updated');
                 setTimeout(() => {
                     bigTempContainer.classList.remove('updated');
                 }, 300); // Match animation duration
            }
            // Ensure text color is always white for contrast
            bigTempElement.style.color = "#FFF";
            bigTempContainer.querySelector('.label').style.color = "#FFF";
        }


        // RAIN SINCE 9AM
        let rainSince9Display = rainSince9.toFixed(1) + " mm";
        if (rainSince9 >= 0.2) {
          rainSince9Display = `<span class="highlight-blue">${rainSince9Display}</span>`;
        }
        updateHTML("rainSince9Val", rainSince9Display);

        // RAIN IN LAST MINUTE
        // Handle potential NaN for rain in last minute (might be 0 if sensor inactive)
        if (isNaN(rainInLastMinRaw)) {
          console.warn("Rain/Last Min is NaN. Defaulting to 0.0 mm");
          rainInLastMinRaw = 0.0;
        }
        let rainInLastMinDisplay = rainInLastMinRaw.toFixed(1) + " mm";
        if (rainInLastMinRaw >= 0.2) {
          rainInLastMinDisplay = `<span class="highlight-blue">${rainInLastMinDisplay}</span>`;
        }
        updateHTML("rainInLastMinVal", rainInLastMinDisplay);

        // SOLAR RADIATION
        const solarRad = Math.max(0, solarRadRaw); // Ensure non-negative
        let solarRadDisplay = solarRad.toFixed(1) + " W/m¬≤";
        let solarClass = '';
        if (solarRad === 0) { solarClass = "highlight-lowsolar"; solarRadDisplay += " üåô"; }
        else if (solarRad <= 100) { solarClass = "highlight-darkblue"; }
        else if (solarRad <= 299) { solarClass = "highlight-blue"; }
        else if (solarRad <= 600) { solarClass = "highlight-warmsolar"; }
        else if (solarRad <= 800) { solarClass = "highlight-orange"; }
        else if (solarRad <= 1100) { solarClass = "highlight-hotsolar"; }
        else { solarClass = "highlight-vryhotsolar"; }
        solarRadDisplay = `<span class="${solarClass}">${solarRadDisplay}</span>`;
        updateHTML("solarRadVal", solarRadDisplay);

        // BLACK GLOBE TEMPERATURE
        const globeTempData = getTemperatureColorAndDesc(blackGlobeTemp);
        const globeElem = document.getElementById("blackGlobeTempVal");
        if (globeElem) {
            globeElem.textContent = blackGlobeTemp.toFixed(1);
            globeElem.style.color = globeTempData.color;
        }

        // Radiant Heat Diff Calculation & Box Update
        const radiantDiff = blackGlobeTemp - temperatureRaw;
        const radiantDiffElem = document.getElementById("radiantDiffVal");
        const radiantDiffBox = document.getElementById("radiantDiffBox");
        if (radiantDiffElem && radiantDiffBox) {
            const diffFormatted = (radiantDiff >= 0 ? "+" : "") + radiantDiff.toFixed(1) + "¬∞C";
            radiantDiffElem.textContent = diffFormatted;
            radiantDiffBox.style.backgroundColor = radiantDiff >= 1.0 ? "#d94a38" // Warm Red (noticeable difference)
                                                : radiantDiff <= -1.0 ? "#4682B4" // Steel Blue (noticeable difference)
                                                : "#808080"; // Gray (neutral/small difference)
            // Ensure text/label remain white
            radiantDiffElem.style.color = "#FFF";
            radiantDiffBox.querySelector('.label').style.color = "#FFF";
        }

        // Temp Above Dew Point Calculation & Box Update
        const dewDiff = temperatureRaw - dewPoint;
        const dewDiffElem = document.getElementById("dewDiffVal");
        const dewDiffBox = document.getElementById("dewDiffBox");
        if (dewDiffElem && dewDiffBox) {
            const dewFormatted = (dewDiff >= 0 ? "+" : "") + dewDiff.toFixed(1) + "¬∞C";
            dewDiffElem.textContent = dewFormatted;
            // Color based on humidity implication
            dewDiffBox.style.backgroundColor = dewDiff < 1.5 ? "#4682B4" // Blue (Humid - close to dew point)
                                              : dewDiff > 3.0 ? "#D2B48C" // Tan (Dry - far from dew point)
                                              : "#808080"; // Gray (Moderate)
            // Ensure text/label remain white
            dewDiffElem.style.color = "#FFF";
            dewDiffBox.querySelector('.label').style.color = "#FFF";
        }

        // GARDEN BED TEMP
        updateText("gardenBedTempVal", gardenBedTemp.toFixed(1));

        // PRESSURE (with standard offset, adjust if local calibration differs)
        const PRESSURE_OFFSET = 1.9; // Assumed standard offset for this location/sensor type
        let adjustedPressure = pressureRaw - PRESSURE_OFFSET;
        let pressureDisplay = adjustedPressure.toFixed(1) + " hPa";
        if (adjustedPressure >= 1020) { // High pressure indication
          pressureDisplay = `<span class="highlight-green">${pressureDisplay} <span aria-label="High pressure, good fishing">üêü</span></span>`;
        } else if (adjustedPressure <= 1000) { // Low pressure indication
           pressureDisplay = `<span class="highlight-orange">${pressureDisplay} <span aria-label="Low pressure"> L</span></span>`;
        }
        updateHTML("pressureVal", pressureDisplay);

        // BATTERY
        const batteryVoltage = batteryVoltageVal.toFixed(1);
        let batteryClass = batteryVoltageVal < 12.2 ? "highlight-red" // Critical low
                         : batteryVoltageVal < 12.5 ? "highlight-orange" // Low
                         : batteryVoltageVal >= 13.8 ? "highlight-green" // Charging/Full
                         : ""; // Normal range, no highlight
        let batteryVoltageDisplay = `<span class="${batteryClass}">${batteryVoltage} V</span>`;
        updateHTML("batteryVal", batteryVoltageDisplay);

        // LOAD
        updateText("loadVal", loadCurrent.toFixed(1));

        // SOLAR PANEL VOLTAGE (Show 0V and Moon if below battery voltage, indicating night/no charge)
        let solarPanelDisplay = rawSolarVoltage > batteryVoltageVal ? rawSolarVoltage.toFixed(1) + " V ‚òÄÔ∏è" : "0.0 V üåô";
        updateText("solarPanelVal", solarPanelDisplay);

        // CHARGE CURRENT (Positive value = charging battery)
        let chargeDisplay = chargeCurrent.toFixed(1) + " mA";
        // Color based on net charge/discharge (Charge - Load) if voltage isn't already high (indicating full/float)
        if (batteryVoltageVal < 13.80) {
            const netCurrent = chargeCurrent - loadCurrent;
            if (netCurrent > 10) { // Charging significantly
                chargeDisplay = `<span class="highlight-green">${chargeDisplay}</span>`;
            } else if (netCurrent < -10) { // Discharging significantly
                chargeDisplay = `<span class="highlight-red">${chargeDisplay}</span>`;
            }
        } else {
            // If voltage is high, even small charge current is okay (float charge)
             if (chargeCurrent > 0) chargeDisplay = `<span class="highlight-green">${chargeDisplay}</span>`;
        }
        updateHTML("chargeVal", chargeDisplay);

        // PEAK WIND GUST (Last 10 minutes)
        let peakWindGustDisplay = peakWindGustVal.toFixed(1) + " km/h";
        if (peakWindGustVal > 35) { // Strong gust
            peakWindGustDisplay = `<span class="highlight-red">${peakWindGustDisplay}</span>`;
        } else if (peakWindGustVal > 20) { // Moderate gust
            peakWindGustDisplay = `<span class="highlight-orange">${peakWindGustDisplay}</span>`;
        }
        updateHTML("peakWindGustVal", peakWindGustDisplay);

        // VECTOR WIND
        updateText("vectorWindSpeedVal", vectorWindSpeedVal.toFixed(1));
        updateText("vectorWindDirDegVal", vectorWindDirVal.toFixed(1));
        updateText("vectorWindDirTextVal", getWindDirection(vectorWindDirVal));

        // EVAP & DEW POINT
        updateText("evapRateVal", evapRate.toFixed(3));
        updateText("dailyEvapVal", dailyEvap.toFixed(3));
        updateText("dewPointVal", dewPoint.toFixed(1));

        // SOIL TEMPS
        updateText("soilTemp10Val", soilTemp10.toFixed(1));
        updateText("soilTemp20Val", soilTemp20.toFixed(1));
        updateText("soilTemp30Val", soilTemp30.toFixed(1));
        updateText("soilTemp40Val", soilTemp40.toFixed(1));

        // SOIL MOISTURE (Using helper for coloring)
        updateHTML("moisture10Val", colorMoisture(moisture10Val));
        updateHTML("moisture20Val", colorMoisture(moisture20Val));
        updateHTML("moisture30Val", colorMoisture(moisture30Val));
        updateHTML("moisture40Val", colorMoisture(moisture40Val));

        // Update Last Updated Timestamp
        const now = new Date();
        updateText("lastUpdatedTimestamp", now.toLocaleTimeString());

        return true; // Indicate successful update

      } catch (error) {
        console.error("Error processing data:", error);
        setStatusBadge("Processing Error", "error");
         if (!initialLoadComplete) {
             document.getElementById("weatherData").innerHTML = `<p style="color: red; text-align: center; padding: 20px;"><b>Error:</b> An internal error occurred while processing weather data.</p>`;
             document.getElementById("weatherData").style.display = "block";
         }
        return false; // Indicate update failure
      }
    }

    /*****************************
     * FETCH & AUTO-REFRESH LOGIC *
     *****************************/
    function fetchWeather() {
        const spinnerContainer = document.getElementById("spinnerContainer");
        const fetchBtn = document.getElementById("fetchBtn");

        // Indicate fetching state
        setStatusBadge("Fetching...", "fetching");
        spinnerContainer.style.display = "block"; // Show spinner
        fetchBtn.disabled = true; // Disable button during fetch

        // Clear previous timeout if any (e.g., if manual fetch was triggered)
        if (refreshTimeout) {
            clearTimeout(refreshTimeout);
        }

        fetch(WEATHER_ENDPOINT)
            .then(response => {
                if (!response.ok) {
                    // Server returned an error (e.g., 404, 500)
                    throw new Error(`Server responded with ${response.status}: ${response.statusText}`);
                }
                return response.text(); // Get response body as text
            })
            .then(data => {
                // Attempt to update the weather data display
                const updateSuccess = updateWeatherData(data);

                if (updateSuccess) {
                    setStatusBadge("Connected", "connected");
                    retryAttempts = 0; // Reset retries on success
                    if (!initialLoadComplete) {
                        initialLoadComplete = true;
                        // Optional: Fade in the data smoothly on first load
                        // document.getElementById("weatherData").style.opacity = 0;
                        // setTimeout(() => { document.getElementById("weatherData").style.transition = "opacity 0.5s"; document.getElementById("weatherData").style.opacity = 1; }, 50);
                    }
                    // Schedule the next fetch
                    scheduleNextFetch();
                } else {
                    // updateWeatherData handled the error state display
                    // Still attempt retry logic as it might be a transient data format issue
                    handleFetchError(new Error("Data processing failed"));
                }
            })
            .catch(error => {
                // Handle network errors or server errors thrown earlier
                console.error("Fetch error:", error);
                handleFetchError(error);
            })
            .finally(() => {
                // Hide spinner and re-enable button regardless of outcome (unless retry is immediate)
                // Let handleFetchError manage the button state if retrying quickly
                 if (retryAttempts === 0 || retryAttempts >= MAX_RETRY_ATTEMPTS) {
                    spinnerContainer.style.display = "none";
                    fetchBtn.disabled = false;
                 }
            });
    }

    function handleFetchError(error) {
        retryAttempts++;
        console.log(`Fetch attempt ${retryAttempts} failed.`);

        if (retryAttempts >= MAX_RETRY_ATTEMPTS) {
            // Max retries reached, show persistent error, schedule longer backoff retry
            setStatusBadge("Error", "error");
            console.log(`Max retry attempts (${MAX_RETRY_ATTEMPTS}) reached. Scheduling longer retry.`);
            // Exponential backoff, capped at MAX_BACKOFF_DELAY
            const backoffDelay = Math.min(MAX_BACKOFF_DELAY, RETRY_DELAY_LONG * Math.pow(2, retryAttempts - MAX_RETRY_ATTEMPTS));
            refreshTimeout = setTimeout(fetchWeather, backoffDelay);
            // Ensure spinner is hidden and button is enabled after failed retries
            document.getElementById("spinnerContainer").style.display = "none";
            document.getElementById("fetchBtn").disabled = false;

        } else {
            // Attempt immediate retry with short delay
            setStatusBadge("Retrying...", "fetching"); // Show retrying status
             const retryDelay = (retryAttempts === 1) ? RETRY_DELAY_SHORT : RETRY_DELAY_LONG;
            refreshTimeout = setTimeout(fetchWeather, retryDelay);
            console.log(`Retrying fetch in ${retryDelay}ms...`);
            // Keep button disabled and spinner potentially visible during quick retries
             document.getElementById("spinnerContainer").style.display = "block";
             document.getElementById("fetchBtn").disabled = true;
        }
    }

    function scheduleNextFetch() {
        if (refreshTimeout) {
            clearTimeout(refreshTimeout); // Clear any existing timeout
        }
        const now = new Date();
        const currentSecond = now.getSeconds();
        let delay;

        if (currentSecond < SCHEDULE_TARGET_SECOND) {
            // Schedule for target second in the current minute
            delay = (SCHEDULE_TARGET_SECOND - currentSecond) * 1000 - now.getMilliseconds();
        } else {
            // Schedule for target second in the next minute
            delay = ((60 - currentSecond) + SCHEDULE_TARGET_SECOND) * 1000 - now.getMilliseconds();
        }

        // Ensure delay is positive (minimum ~1 second)
        delay = Math.max(1000, delay);

        console.log(`Scheduling next fetch in ${Math.round(delay / 1000)} seconds.`);
        refreshTimeout = setTimeout(fetchWeather, delay);
    }

    function manualFetch() {
        console.log("Manual fetch requested.");
        if (refreshTimeout) {
            clearTimeout(refreshTimeout); // Stop scheduled refresh
        }
        retryAttempts = 0; // Reset retry counter on manual fetch
        fetchWeather(); // Fetch immediately
    }

    // Initial Setup on Load
    window.addEventListener("load", () => {
        setStatusBadge("Waiting...", "waiting"); // Initial status
        fetchWeather(); // Start the fetch process
    });

    // Optional: Add visibility change listener to potentially pause/resume updates
    // document.addEventListener("visibilitychange", () => {
    //     if (document.hidden) {
    //         console.log("Page hidden, pausing auto-refresh.");
    //         clearTimeout(refreshTimeout);
    //     } else {
    //         console.log("Page visible, resuming auto-refresh.");
    //         manualFetch(); // Fetch immediately on becoming visible
    //     }
    // });

  </script>
</body>
</html>