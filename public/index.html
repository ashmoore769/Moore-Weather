<!DOCTYPE html>
<html lang="en">
<head>
  <!-- ... (head content remains the same as the previous 'good' version) ... -->
  <link rel="apple-touch-icon" href="/Weather_Station_App.png">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Rubik:wght@600&display=swap" rel="stylesheet">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Moore's LIVE Weather Data</title>
  <style>
    /* ... (Keep MOST of the CSS from the previous version) ... */

    /* !!! KEY CSS CHANGES !!! */
    #weatherData p {
      margin: 3px 0; /* Slightly increased vertical margin */
      line-height: 1.4; /* Slightly increased line-height for emoji room */
      white-space: nowrap;
      display: flex; /* Use flexbox for better alignment with emojis */
      align-items: baseline; /* Align text baseline */
    }
    #weatherData p .emoji { /* Style the emoji container */
        display: inline-block;
        width: 20px; /* Fixed width for alignment */
        text-align: center; /* Center emoji in its box */
        margin-right: 5px; /* Space between emoji and label */
    }

    #weatherData p b {
        color: var(--label-text);
        font-weight: 600;
        /* REMOVED min-width */
        /* REMOVED ::after */
        margin-right: 5px; /* Add space after the bold label */
    }

     /* Adjust specific column label widths if needed, targeting the <b> tag */
     #weatherData .evap-battery b,
     #weatherData .soil-moisture b {
       /* You might need min-width here if alignment is desired across columns */
       /* min-width: 90px; */ /* Example */
       display: inline-block; /* Helps if using min-width */
     }


     /* Keep the date/time specific styles from before */
    .date-time p b {
       min-width: 45px; /* Keep date/time alignment */
       margin-right: 5px;
    }
     /* Remove default flex behavior from date/time if it conflicts */
    .date-time p {
        display: block; /* Override flex for date/time if needed */
    }
    .date-time p .emoji { width: auto; margin-right: 5px;} /* Adjust date/time emoji spacing */


    /* --- Other Data Sections (minor adjustments for spacing if needed) --- */
    .rain-container {
      margin-top: 7px;
      margin-bottom: 3px;
      padding: 3px 8px; /* Adjusted padding slightly */
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background: #f9f9f9;
    }
     /* Ensure rain container paragraphs also use flex */
    .rain-container p {
        display: flex;
        align-items: baseline;
    }
    .rain-container p .emoji {
        width: 20px; text-align: center; margin-right: 5px;
    }
     .rain-container p b {
       margin-right: 5px;
     }

    /* ... (Rest of the CSS remains the same) ... */

     /* --- Media Queries adjustments if needed --- */
     @media only screen and (max-width: 600px) {
       /* ... existing responsive styles ... */
        .date-time p b { min-width: 40px;}
     }
     @media only screen and (max-width: 360px) {
        /* ... existing responsive styles ... */
        .date-time p b { min-width: 35px;}
     }

  </style>
</head>
<body>
  <div class="main-container">
    <!-- Sticky Header (no changes needed) -->
    <div class="freeze-pane">
        <!-- ... -->
         <div class="control-container">
            <div class="control-half">
              <button id="fetchBtn" onclick="manualFetch()">CURRENT READINGS</button>
            </div>
            <div class="control-half">
              <p id="status" aria-live="polite">
                <span id="statusBadge" class="status-badge waiting">⏳ Status: Waiting...</span>
              </p>
            </div>
          </div>
    </div>

    <!-- Weather Data Section -->
    <div id="weatherData">
      <!-- Header Section -->
      <div class="header-content">
        <div class="title-date-container">
          <div class="address-title">WEST WARWICK, QLD</div>
          <div class="date-time">
            <!-- Emojis added -->
            <p><span class="emoji">📆</span><b>Date:</b> <span id="dateVal">--</span></p>
            <p><span class="emoji">⏰</span><b>Time:</b> <span id="timeVal">--</span></p>
          </div>
        </div>
        <div class="logo-container">
           <img src="/Weather_Station_App.png" alt="Weather Station Icon">
           <img src="/Station_Label.png" alt="Environdata Weather Maestro">
        </div>
      </div>
      <hr>

      <!-- Main Data Columns -->
      <div class="wind-logger-container">
        <div class="wind-column">
          <!-- Emojis added -->
          <p><span class="emoji">💨</span><b>Wind Speed:</b> <span id="windSpeedVal">--</span> km/h</p>
          <p><span class="emoji">🧭</span><b>Wind Dir.:</b> <span id="windDirDegVal">--</span>° (<span id="windDirTextVal">--</span>)</p>
          <p><span class="emoji">💦</span><b>Humidity:</b> <span id="humidityVal">--</span>% (<span id="humidityDescVal">--</span>)</p>
          <p><span class="emoji">🌡️</span><b>Temperature:</b>
            <span id="tempVal" style="font-weight:bold;">--</span>
            (<span id="tempDescVal">--</span>)
          </p>
          <p><span class="emoji">☀️</span><b>Solar Rad.:</b> <span id="solarRadVal">--</span></p> <!-- Emoji here matches conditional emoji logic -->
          <p><span class="emoji">⚫</span><b>Black Globe:</b> <span id="blackGlobeTempVal">--</span>°C</p> <!-- Used a simple circle -->
          <p><span class="emoji">🌱</span><b>Garden Bed:</b> <span id="gardenBedTempVal">--</span>°C</p>
          <p><span class="emoji">🌀</span><b>Pressure:</b> <span id="pressureVal">--</span></p>
          <div class="rain-container">
            <p><span class="emoji">🌧️</span><b>Rain Since 9AM:</b> <span id="rainSince9Val">--</span></p>
            <p><span class="emoji">💧</span><b>Rain / Last Min:</b> <span id="rainInLastMinVal">--</span></p> <!-- Different rain emoji maybe? -->
          </div>
        </div>
        <div class="logger-column">
            <!-- Big temp boxes - no emojis needed here -->
          <div class="big-temp-box" id="airTempBox">
            <span id="bigTempVal">--°C</span>
            <span class="label">Air Temp</span>
          </div>
          <div class="big-temp-box" id="radiantDiffBox">
            <span id="radiantDiffVal">--</span>
            <span class="label" aria-label="Difference between black globe and air temperature">Rad. Heat Diff</span>
          </div>
        </div>
      </div>
      <hr>
      <!-- Evaporation and Battery Section -->
      <div class="evap-battery">
        <div class="evap-col">
          <!-- Emojis added -->
          <p><span class="emoji">⤴️</span><b>Evap/Hr:</b> <span id="evapRateVal">--</span> mm/h</p>
          <p><span class="emoji">⬆️</span><b>Daily Evap:</b> <span id="dailyEvapVal">--</span> mm</p>
          <p><span class="emoji">💧</span><b>Dew Point:</b> <span id="dewPointVal">--</span>°C</p>
          <p><span class="emoji">🌬️</span><b>Max WS Gust:</b> <span id="peakWindGustVal">--</span></p>
        </div>
        <div class="battery-col">
          <!-- Emojis added -->
          <p><span class="emoji">🔋</span><b>Battery:</b> <span id="batteryVal">--</span></p>
          <p><span class="emoji">⚡</span><b>Load:</b> <span id="loadVal">--</span> mA</p>
          <p><span class="emoji">☀️</span><b>Solar Panel:</b> <span id="solarPanelVal">--</span></p> <!-- Emoji here matches conditional emoji logic -->
          <p><span class="emoji">🔌</span><b>Charge:</b> <span id="chargeVal">--</span></p>
        </div>
      </div>
      <hr>
      <!-- Additional Data -->
      <!-- Emojis added -->
      <p><span class="emoji">🍃</span><b>Vector Wind Spd:</b> <span id="vectorWindSpeedVal">--</span> km/h</p>
      <p><span class="emoji">🧭</span><b>Vector Wind Dir:</b>
        <span id="vectorWindDirDegVal">--</span>° (<span id="vectorWindDirTextVal">--</span>)
      </p>
      <hr>
      <div class="soil-moisture">
        <div class="soiltemp-col">
          <!-- Emojis added -->
          <p><span class="emoji">🌡️</span><b>S.Temp 10cm:</b> <span id="soilTemp10Val">--</span>°C</p>
          <p><span class="emoji">🌡️</span><b>S.Temp 20cm:</b> <span id="soilTemp20Val">--</span>°C</p>
          <p><span class="emoji">🌡️</span><b>S.Temp 30cm:</b> <span id="soilTemp30Val">--</span>°C</p>
          <p><span class="emoji">🌡️</span><b>S.Temp 40cm:</b> <span id="soilTemp40Val">--</span>°C</p>
        </div>
        <div class="moisture-col">
          <!-- Emojis added -->
          <p><span class="emoji">💧</span><b>Moist. 10cm:</b> <span id="moisture10Val">--</span>%</p>
          <p><span class="emoji">💧</span><b>Moist. 20cm:</b> <span id="moisture20Val">--</span>%</p>
          <p><span class="emoji">💧</span><b>Moist. 30cm:</b> <span id="moisture30Val">--</span>%</p>
          <p><span class="emoji">💧</span><b>Moist. 40cm:</b> <span id="moisture40Val">--</span>%</p>
        </div>
      </div>
      <hr>
    </div>

    <!-- Spinner -->
    <div id="spinnerContainer" class="spinner-container">
      <div class="spinner"></div>
    </div>
  </div>

  <script>
    // ... (The JavaScript code from the previous 'good' version remains UNCHANGED) ...
    // Helper functions (getWindDirection, setStatusBadge, formatDateString, etc.)
    // Global State & Retries
    // updateWeatherData function (this will correctly update the spans next to the labels now)
    // Fetch & Auto-Refresh Logic (fetchWeather, scheduleNextFetch, manualFetch)
    // Initial setup and event listener

    /********************
    * HELPER FUNCTIONS *
    ********************/
    function getWindDirection(degrees) {
      const directions = ["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE",
        "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"];
      if (isNaN(degrees)) return '--';
      return directions[Math.round(degrees / 22.5) % 16];
    }

    function setStatusBadge(statusText, statusClass) {
      const icons = {
        connected: "✅",
        fetching: "🔄",
        error: "⚠️",
        waiting: "⏳" // Added waiting state
      };
      const icon = icons[statusClass] || "";
      const badge = document.getElementById("statusBadge");
      badge.textContent = `${icon} Status: ${statusText}`;
      badge.className = 'status-badge'; // Reset classes first
      badge.classList.add(statusClass); // Add the current class
    }

    function formatDateString(dateStr) {
      const parts = dateStr.split("/"); // Expects YYYY/MM/DD
      if (parts.length === 3) {
        const [year, month, day] = parts.map(Number);
        if (!isNaN(year) && !isNaN(month) && !isNaN(day)) {
            const dateObj = new Date(year, month - 1, day);
            if (dateObj && dateObj.getFullYear() === year && dateObj.getMonth() === month - 1 && dateObj.getDate() === day) {
                const formattedDay = String(day).padStart(2, '0');
                const formattedMonth = String(month).padStart(2, '0');
                const formattedDate = `${formattedDay}/${formattedMonth}/${year}`;
                const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
                return `${formattedDate} (${dayNames[dateObj.getDay()]})`;
            }
        }
      }
      console.warn("Could not parse date string:", dateStr);
      return dateStr || '--'; // Return original or default
    }

    function getTemperatureColorAndDesc(temp) {
       // Using color variables defined in CSS :root might be better long term
       // but keeping literal values here for simplicity as per previous code
      let color, desc;
      if (isNaN(temp)) return { color: 'inherit', desc: '--' };
      if (temp < -20) { color = "#000000"; desc = ""; }
      else if (temp < -10) { color = "#191970"; desc = "Severely cold"; }
      else if (temp < 0) { color = "#00008B"; desc = "Extremely cold"; }
      else if (temp < 6) { color = "#104E8B"; desc = "Very cold"; }
      else if (temp < 11) { color = "#4682B4"; desc = "Cold"; }
      else if (temp < 16) { color = "#32CD32"; desc = "Cool"; }
      else if (temp < 21) { color = "#228B22"; desc = "Mild"; }
      else if (temp < 28) { color = "#D4A017"; desc = "Warm"; }
      else if (temp < 32) { color = "#FF8C00"; desc = "Warmer"; }
      else if (temp < 36) { color = "#FF4500"; desc = "Hot"; }
      else if (temp < 41) { color = "#B22222"; desc = "Very hot"; }
      else if (temp <= 60) { color = "#8B0000"; desc = "Extremely hot"; }
      else { color = "#000000"; desc = ""; }
      return { color, desc };
    }

    function getHumidityDesc(humidity) {
      if (isNaN(humidity)) return '--';
      if (humidity <= 20) { return "Very Dry"; }
      else if (humidity <= 40) { return "Dry"; }
      else if (humidity <= 60) { return "Comfortable"; }
      else if (humidity <= 80) { return "Humid"; }
      else { return "Very Humid"; }
    }

    function colorMoisture(val) {
        if (isNaN(val)) return '--';
        let display = val.toFixed(1);
        // Example: Highlight very dry in orange/bold
        if (val < 20) { display = `<span style="color:#D4A017; font-weight:bold;">${display}</span>`; }
        // Example: Highlight very wet in blue/bold
        else if (val > 85) { display = `<span style="color:#1E90FF; font-weight:bold;">${display}</span>`;}
        return display;
    }

    // Helper to safely get numeric value from lines array
    function safeGetLineValue(lines, index, defaultValue = NaN) {
        if (index >= lines.length || typeof lines[index] === 'undefined' || lines[index] === null || lines[index].trim() === '') {
             console.warn(`safeGetLineValue: No data at index ${index}`);
             return defaultValue;
        }
        const val = parseFloat(lines[index]);
         if (isNaN(val)) {
            // console.warn(`safeGetLineValue: Value at index ${index} ("${lines[index]}") is not a number.`);
            return defaultValue;
         }
        return val;
    }
     // Helper to safely get string value
     function safeGetLineString(lines, index, defaultValue = '--') {
         if (index >= lines.length || typeof lines[index] === 'undefined' || lines[index] === null || lines[index].trim() === '') {
              // console.warn(`safeGetLineString: No data at index ${index}`);
             return defaultValue;
         }
         return lines[index].trim();
     }


    /*****************************
    * GLOBAL STATE & RETRIES *
    *****************************/
    let initialLoadComplete = false;
    let refreshTimeout;
    let retryAttempts = 0;
    const MAX_RETRY_ATTEMPTS = 3; // Short-term retries
    const LONG_RETRY_DELAY = 30000; // 30 seconds for longer backoff
    const WEATHER_ENDPOINT = "/weather"; // Relative path for server endpoint

    /*****************************
    * MAIN UPDATE FUNCTION *
    *****************************/
    function updateWeatherData(data) {
      // console.log("Raw CSV data received length:", data.length);
      // Remove potential leading "r3" and \r characters, trim whitespace, split by comma
      const cleanedData = data.replace(/^r3\s*/, '').replace(/\r/g, '').trim();
      const lines = cleanedData.split(",");
      console.log(`Parsed ${lines.length} fields from CSV.`);

      // Robust check for expected data length
      const EXPECTED_FIELDS = 31; // Based on index 30 being the last used (blackGlobeTemp)
      if (lines.length < EXPECTED_FIELDS) {
        console.error(`Incomplete data received. Expected >= ${EXPECTED_FIELDS} fields, got: ${lines.length}`, lines);
        setStatusBadge("Data Error", "error");
        // Decide how to handle: clear fields, show error message, keep old data?
        // Keeping old data might be less jarring than clearing everything.
        return; // Stop processing if data structure is wrong
      }

      try {
        // Extract data using safe helpers
        const dateStr = safeGetLineString(lines, 0);
        const timeStr = safeGetLineString(lines, 1);
        const windSpeed = safeGetLineValue(lines, 2);
        const windDirDeg = safeGetLineValue(lines, 3);
        const humidityRaw = safeGetLineValue(lines, 4);
        const temperatureRaw = safeGetLineValue(lines, 5);
        let rainInLastMinRaw = safeGetLineValue(lines, 6, 0.0); // Default to 0 if NaN
        const solarRadRaw = safeGetLineValue(lines, 7);
        const pressureRaw = safeGetLineValue(lines, 8);
        const gardenBedTemp = safeGetLineValue(lines, 9);
        const batteryVoltageVal = safeGetLineValue(lines, 10);
        const loadCurrent = safeGetLineValue(lines, 11);
        const rawSolarVoltage = safeGetLineValue(lines, 12);
        const chargeCurrent = safeGetLineValue(lines, 13);
        const peakWindGustVal = safeGetLineValue(lines, 14);
        const vectorWindSpeedVal = safeGetLineValue(lines, 15);
        const vectorWindDirVal = safeGetLineValue(lines, 16);
        const rainSince9 = safeGetLineValue(lines, 17);
        const evapRate = safeGetLineValue(lines, 18);
        // Index 19 unused
        const dailyEvap = safeGetLineValue(lines, 20);
        const dewPoint = safeGetLineValue(lines, 21);
        const soilTemp10 = safeGetLineValue(lines, 22);
        const soilTemp20 = safeGetLineValue(lines, 23);
        const soilTemp30 = safeGetLineValue(lines, 24);
        const soilTemp40 = safeGetLineValue(lines, 25);
        const moisture10Val = safeGetLineValue(lines, 26);
        const moisture20Val = safeGetLineValue(lines, 27);
        const moisture30Val = safeGetLineValue(lines, 28);
        const moisture40Val = safeGetLineValue(lines, 29);
        const blackGlobeTemp = safeGetLineValue(lines, 30);

        // *** UPDATE DOM ELEMENTS *** (Using helper function for safety)

        const updateElement = (id, value, unit = '') => {
            const element = document.getElementById(id);
            if (element) {
                 // Check if value is fundamentally invalid (NaN for numbers, '--' for strings)
                if ((typeof value === 'number' && isNaN(value)) || value === '--') {
                    element.textContent = '--';
                     if (unit) element.textContent += ` ${unit}`; // Append unit even to '--'
                } else {
                     // Format numbers nicely
                    if (typeof value === 'number') {
                         if (id.includes('evap') || id.includes('Evap')) {
                            element.textContent = value.toFixed(3); // 3 decimal places for evap
                         } else {
                            element.textContent = value.toFixed(1); // 1 decimal place default
                         }
                    } else {
                        element.textContent = value; // Assign string directly
                    }
                    if (unit) element.textContent += ` ${unit}`;
                }
            } else {
                console.warn(`Element with ID ${id} not found.`);
            }
        };

         const updateHTML = (id, content) => {
            const element = document.getElementById(id);
            if (element) {
                element.innerHTML = content; // Use innerHTML for tags
            } else {
                 console.warn(`Element with ID ${id} not found.`);
            }
        };

        // DATE & TIME
        updateElement("dateVal", formatDateString(dateStr));
        updateElement("timeVal", timeStr !== '--' ? timeStr + " AEST" : '--');

        // WIND
        updateElement("windSpeedVal", windSpeed); // Unit added in HTML
        updateElement("windDirDegVal", windDirDeg); // Unit added in HTML
        updateElement("windDirTextVal", getWindDirection(windDirDeg)); // Text only

        // HUMIDITY
        updateElement("humidityVal", humidityRaw); // Unit added in HTML
        updateElement("humidityDescVal", getHumidityDesc(humidityRaw)); // Text only

        // TEMPERATURE
        const tempSpan = document.getElementById("tempVal");
        const tempDescSpan = document.getElementById("tempDescVal");
        const bigTempElement = document.getElementById("bigTempVal");
        const bigTempContainer = document.getElementById("airTempBox");

        if (!isNaN(temperatureRaw)) {
            const tempData = getTemperatureColorAndDesc(temperatureRaw);
            tempSpan.textContent = temperatureRaw.toFixed(1) + "°C";
            tempSpan.style.color = tempData.color;
            tempDescSpan.textContent = tempData.desc;

            bigTempElement.textContent = temperatureRaw.toFixed(1) + "°C";
            bigTempContainer.style.backgroundColor = tempData.color;
            bigTempElement.style.color = "#FFF"; // Ensure text is white

            bigTempContainer.classList.add('updated');
            setTimeout(() => bigTempContainer.classList.remove('updated'), 300);
        } else {
            tempSpan.textContent = '--°C';
            tempSpan.style.color = 'inherit';
            tempDescSpan.textContent = '--';
            bigTempElement.textContent = '--°C';
            bigTempContainer.style.backgroundColor = 'grey';
        }

         // RAIN SINCE 9AM
        let rainSince9Display = !isNaN(rainSince9) ? rainSince9.toFixed(1) + " mm" : '-- mm';
        if (!isNaN(rainSince9) && rainSince9 >= 0.2) {
          rainSince9Display = `<span style="color:#1E90FF; font-weight:bold;">${rainSince9Display}</span>`;
        }
        updateHTML("rainSince9Val", rainSince9Display);

        // RAIN IN LAST MINUTE
        let rainInLastMinDisplay = rainInLastMinRaw.toFixed(1) + " mm"; // Already defaulted to 0 if NaN
        if (rainInLastMinRaw >= 0.2) {
          rainInLastMinDisplay = `<span style="color:#1E90FF; font-weight:bold;">${rainInLastMinDisplay}</span>`;
        }
         updateHTML("rainInLastMinVal", rainInLastMinDisplay);

        // SOLAR RADIATION
        const solarRad = !isNaN(solarRadRaw) ? Math.max(0, solarRadRaw) : NaN;
        let solarRadDisplay = '-- W/m²';
        if (!isNaN(solarRad)) {
            let solarRadColor = solarRad === 0 ? "#000033" :
                solarRad <= 100 ? "#000080" :
                solarRad <= 299 ? "#27408B" :
                solarRad <= 600 ? "#DAA520" : // Gold
                solarRad <= 800 ? "#FF9933" : // Orange
                solarRad <= 1100 ? "#BF360C" : // Deep Orange
                "#B71C1C"; // Red
            solarRadDisplay = solarRad.toFixed(1) + " W/m²";
            // Add moon if effectively zero/dark
            if (solarRad < 5) solarRadDisplay += " 🌙";
             // Style with color, make bold if significant radiation
            solarRadDisplay = `<span style="font-weight:${solarRad >= 5 ? 'bold' : 'normal'}; color:${solarRadColor};">${solarRadDisplay}</span>`;
        }
         updateHTML("solarRadVal", solarRadDisplay);

        // BLACK GLOBE & RADIANT HEAT DIFF
        const globeElem = document.getElementById("blackGlobeTempVal");
        const radiantDiffElem = document.getElementById("radiantDiffVal");
        const radiantDiffBox = document.getElementById("radiantDiffBox");
        if (!isNaN(blackGlobeTemp)) {
            const globeTempData = getTemperatureColorAndDesc(blackGlobeTemp);
             updateElement("blackGlobeTempVal", blackGlobeTemp); // Unit in HTML
             globeElem.style.color = globeTempData.color; // Apply color to value only

            if (!isNaN(temperatureRaw)) {
                const radiantDiff = blackGlobeTemp - temperatureRaw;
                const diffFormatted = (radiantDiff >= 0 ? "+" : "") + radiantDiff.toFixed(1) + "°C";
                radiantDiffElem.textContent = diffFormatted;
                radiantDiffBox.style.backgroundColor = radiantDiff >= 0 ? "#d94a38" : "#4682B4";
                radiantDiffElem.style.color = "white";
            } else {
                 radiantDiffElem.textContent = '--°C';
                 radiantDiffBox.style.backgroundColor = 'grey';
            }
        } else {
             updateElement("blackGlobeTempVal", NaN); // Show '--'
             globeElem.style.color = 'inherit';
             radiantDiffElem.textContent = '--°C';
             radiantDiffBox.style.backgroundColor = 'grey';
        }

        // GARDEN BED TEMP
        updateElement("gardenBedTempVal", gardenBedTemp); // Unit in HTML

        // PRESSURE (with 1.9 hPa offset)
        let pressureDisplay = '-- hPa';
        if (!isNaN(pressureRaw)) {
            let adjustedPressure = pressureRaw - 1.9;
            pressureDisplay = adjustedPressure.toFixed(1) + " hPa";
             // Highlight high pressure
            if (adjustedPressure >= 1021.5) { // Adjusted threshold slightly
                pressureDisplay = `<span style="color:green; font-weight:bold;">${pressureDisplay} 👍</span>`; // Fish maybe too specific?
            } else if (adjustedPressure < 1005) { // Highlight low pressure
                 pressureDisplay = `<span style="color:#4682B4; font-weight:bold;">${pressureDisplay}</span>`;
            }
        }
        updateHTML("pressureVal", pressureDisplay);

        // BATTERY
        let batteryVoltageDisplay = '-- V';
        if (!isNaN(batteryVoltageVal)) {
            const batteryVoltage = batteryVoltageVal.toFixed(1);
            let batteryStyle = "color:";
            if (batteryVoltageVal < 12.5) {
                batteryStyle += "red; font-weight:bold;"; // Low and bold
            } else if (batteryVoltageVal >= 13.9) { // Increased threshold for 'full' bold
                 batteryStyle += "green; font-weight:bold;"; // Full and bold
            } else {
                batteryStyle += "green;"; // Normal range
            }
            batteryVoltageDisplay = `<span style="${batteryStyle}">${batteryVoltage} V</span>`;
        }
        updateHTML("batteryVal", batteryVoltageDisplay);

        // LOAD
        updateElement("loadVal", loadCurrent); // Unit in HTML

        // SOLAR PANEL
        let solarPanelDisplay = '-- V';
        if (!isNaN(rawSolarVoltage) && !isNaN(batteryVoltageVal)) {
            // Display 0.0V if effectively no useful voltage (e.g., less than battery or very low)
             const effectiveSolarVoltage = (rawSolarVoltage < batteryVoltageVal || rawSolarVoltage < 1.0 )
                                        ? 0.0 : rawSolarVoltage;
             solarPanelDisplay = effectiveSolarVoltage.toFixed(1) + " V";
             if (effectiveSolarVoltage <= 0.1) solarPanelDisplay += " 🌙"; // Add moon only if truly dark
             else solarPanelDisplay += " ☀️";
        }
        updateHTML("solarPanelVal", solarPanelDisplay); // Use updateHTML because of emoji logic

        // CHARGE
        let chargeDisplay = '-- mA';
         if (!isNaN(chargeCurrent) && !isNaN(loadCurrent) && !isNaN(batteryVoltageVal)) {
            chargeDisplay = chargeCurrent.toFixed(1) + " mA";
             let chargeStyle = "";
            // Style based on charging state relative to load, unless battery is full
             if (batteryVoltageVal < 13.9) { // Only color-code if not full
                chargeStyle = chargeCurrent > loadCurrent ? "color:green;" : "color:red;";
             } else if (chargeCurrent > 0) { // If full but still drawing current (trickle charge)
                 chargeStyle = "color:green;"; // Show as green
             } // Else: Full and 0mA charge, no specific style needed (default black)

            chargeDisplay = `<span style="${chargeStyle}">${chargeDisplay}</span>`;
        }
        updateHTML("chargeVal", chargeDisplay);

        // PEAK WIND GUST
        let peakWindGustDisplay = '-- km/h';
        if (!isNaN(peakWindGustVal)) {
            peakWindGustDisplay = peakWindGustVal.toFixed(1) + " km/h";
            if (peakWindGustVal > 25) { // Strong gust
                peakWindGustDisplay = `<span style="color:red; font-weight:bold;">${peakWindGustDisplay}</span>`;
            } else if (peakWindGustVal > 10) { // Moderate gust
                peakWindGustDisplay = `<span style="color:#FF8C00; font-weight:bold;">${peakWindGustDisplay}</span>`;
            }
        }
        updateHTML("peakWindGustVal", peakWindGustDisplay);

        // VECTOR WIND
        updateElement("vectorWindSpeedVal", vectorWindSpeedVal); // Unit in HTML
        updateElement("vectorWindDirDegVal", vectorWindDirVal); // Unit in HTML
        updateElement("vectorWindDirTextVal", getWindDirection(vectorWindDirVal)); // Text only

        // EVAP & DEW POINT (Units in HTML)
        updateElement("evapRateVal", evapRate);
        updateElement("dailyEvapVal", dailyEvap);
        updateElement("dewPointVal", dewPoint);

        // SOIL TEMPS & MOISTURE (Units in HTML)
        updateElement("soilTemp10Val", soilTemp10);
        updateElement("soilTemp20Val", soilTemp20);
        updateElement("soilTemp30Val", soilTemp30);
        updateElement("soilTemp40Val", soilTemp40);

        updateHTML("moisture10Val", colorMoisture(moisture10Val));
        updateHTML("moisture20Val", colorMoisture(moisture20Val));
        updateHTML("moisture30Val", colorMoisture(moisture30Val));
        updateHTML("moisture40Val", colorMoisture(moisture40Val));

      } catch (error) {
        console.error("Error processing weather data:", error);
        setStatusBadge("Processing Error", "error");
        // Avoid clearing fields, just show error status
      }
    }


    /*****************************
     * FETCH & AUTO-REFRESH LOGIC *
     *****************************/
    function fetchWeather() {
        const spinnerContainer = document.getElementById("spinnerContainer");
        const fetchBtn = document.getElementById("fetchBtn");

        // Don't show spinner immediately if already connected, avoids flicker
        if (!initialLoadComplete || document.getElementById("statusBadge").classList.contains('error') || document.getElementById("statusBadge").classList.contains('waiting')) {
             spinnerContainer.style.display = "block";
        }
        setStatusBadge("Fetching", "fetching");
        fetchBtn.disabled = true;

        fetch(WEATHER_ENDPOINT)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Server responded ${response.status} - ${response.statusText || 'Error'}`);
                }
                return response.text();
            })
            .then(data => {
                if (!data || data.trim() === "" || !data.includes(',')) { // Check for empty or invalid data
                    throw new Error("Received empty or invalid data from server");
                }
                updateWeatherData(data); // Process data
                setStatusBadge("Connected", "connected"); // Set status AFTER processing
                retryAttempts = 0; // Reset retries on success
                if (!initialLoadComplete) {
                    initialLoadComplete = true;
                }
                scheduleNextFetch(); // Schedule next ONLY on success
            })
            .catch(error => {
                console.error("Fetch error:", error.message);
                retryAttempts++;
                initialLoadComplete = true; // Allow hiding spinner even if first load fails

                if (retryAttempts <= MAX_RETRY_ATTEMPTS) {
                    setStatusBadge(`Retrying (${retryAttempts}/${MAX_RETRY_ATTEMPTS})`, "fetching");
                    const retryDelay = retryAttempts === 1 ? 1000 : 2000; // Slightly longer retry delays
                    console.log(`Retrying fetch in ${retryDelay}ms...`);
                    refreshTimeout = setTimeout(fetchWeather, retryDelay);
                } else {
                    setStatusBadge("Error", "error"); // Persistent error state
                    console.log(`Max retries reached. Retrying in ${LONG_RETRY_DELAY / 1000}s...`);
                    refreshTimeout = setTimeout(fetchWeather, LONG_RETRY_DELAY);
                }
            })
            .finally(() => {
                // Always hide spinner and enable button once an attempt (or retry sequence) completes
                spinnerContainer.style.display = "none";
                fetchBtn.disabled = false;
            });
    }

    function scheduleNextFetch() {
        if (refreshTimeout) {
            clearTimeout(refreshTimeout);
        }
        const now = new Date();
        const seconds = now.getSeconds();
        const milliseconds = now.getMilliseconds();
        let delay;
        const targetSecond = 20; // Aim for 20 seconds past the minute

        if (seconds < targetSecond) {
            delay = (targetSecond - seconds) * 1000 - milliseconds;
        } else {
            delay = ((60 - seconds) + targetSecond) * 1000 - milliseconds;
        }

        delay = Math.max(delay, 1000); // Ensure minimum 1s delay

        console.log(`Next automatic fetch scheduled in ${Math.round(delay / 1000)}s`);
        refreshTimeout = setTimeout(fetchWeather, delay);
    }

    function manualFetch() {
        console.log("Manual fetch requested.");
        if (refreshTimeout) {
            clearTimeout(refreshTimeout);
        }
        retryAttempts = 0; // Reset retry counter
        fetchWeather(); // Fetch immediately
    }

    // Initial state setup
    window.addEventListener("load", () => {
         setStatusBadge("Waiting", "waiting"); // Set initial status correctly
         console.log("Page loaded, initiating first fetch...");
         fetchWeather(); // Start the fetch cycle
    });

  </script>
</body>
</html>